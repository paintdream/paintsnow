
-- Compile.lua --
-- A simple typedlua compiler executable
--

local QuickCompile = {}
EnableTypedlua = true
local BootModule, errMsg = load(System.SnowyStream.FetchFileData("Engine/Boot/Bootstrap.lua"))
if errMsg then
	print("Util syntax error: " .. errMsg)
end

BootModule()
print("QuickCompile started.")
local typedlua = require("typedlua/loader")

local function PrintWithErrorsOnly(...)
	local str = table.concat({...})
	local charLimit = 4096
	for k, i in ipairs(string.split(str, "\n")) do
		if string.find(i, "error") ~= nil then
			if string.len(i) > charLimit then
				i = string.sub(i, 1, charLimit) .. " ..."
			end

			print(i)
		end
	end
end

function QuickCompile:CompileOne(filename, outputfile)
	local filenamelength = string.len(filename)
	-- extract file title
	local title = string.sub(filename, 1, filenamelength - 3)
	print("Compiling: " .. filename .. " ...")
	-- read file content
	local content = SnowyStream.FetchFileData(filename)
	if content then
		local code, err = typedlua.compile(content, title, false, { STRICT = true, INTEGER = true, SHOW_WARNINGS = false}, self.cache)
		if code then
			local t = SnowyStream.NewFile(outputfile, true)
			if t then
				-- removes all continuous returns ...
				local length = string.len(code)
				local shrinkLength = length
				repeat
					length = shrinkLength
					code = string.gsub(code, "\n\n\n", "\n")
					shrinkLength = string.len(code)
				until length == shrinkLength

				-- make header
				local header = "-- " .. outputfile .. "\n"
				header = header .. "-- PaintDream (paintdream@paintdream.com)\n"
				header = header .. "-- Generated By TypedLua Compiler (TLC)\n"
				header = header .. "-- Please do not modify it manually\n"
				header = header .. "-- \n\n"

				local text = header .. string.gsub(code, "  ", "\t")
				SnowyStream.WriteFile(t, text)
				SnowyStream.FlushFile(t)
				SnowyStream.CloseFile(t)
			else
				print("Error on writing file " .. title .. ".lua")
			end
		else
			PrintWithErrorsOnly("Compile error: \n" .. err)
		end
	else
		print("Error on reading file " .. filename)
	end
end

function QuickCompile:BuildUpdatedOne(filename, tree, forceRecompile)
	-- already checked?
	local state = tree[filename]
	if state then -- need compile
		return true
	elseif state == false then
		return false
	end

	tree[filename] = false
	-- check if it was already up to date
	local title = filename:match("(.-)%.[tl|tlm]")
	local outputfile = title .. ".lua"
	if not forceRecompile then
		local source = SnowyStream.NewFile(filename, false)
		if source then
			local checker = SnowyStream.NewFile(outputfile, false)
			if checker then
				local deps = false
				local content = SnowyStream.ReadFile(source, SnowyStream.GetFileSize(source))

				for k in string.gmatch(content, "require.-[%\'%\"](.-)[%\'%\"]") do
					deps = deps or self:BuildUpdatedOne(k .. ".tl", tree) or self:BuildUpdatedOne(k .. ".tlm", tree)
				end

				if not deps then
					local srcLastModifiedTime = SnowyStream.GetFileLastModifiedTime(source)
					local checkerLastModifiedTime = SnowyStream.GetFileLastModifiedTime(checker)
					-- print("TIME " .. srcLastModifiedTime .. " VS " .. checkerLastModifiedTime)
					if checkerLastModifiedTime > srcLastModifiedTime then
						-- already compiled?
						tree[filename] = false
						SnowyStream.CloseFile(source)
						SnowyStream.CloseFile(checker)
						return false
					end
				end
				SnowyStream.CloseFile(checker)
			end
			SnowyStream.CloseFile(source)
		else
			tree[filename] = false
			return false
		end
	end

	tree[filename] = outputfile
	return true
end

function QuickCompile:BuildUpdatedRecursive(path, tree, forceRecompile)
	-- Opens file and search for require statements
	assert(type(path) == "string", debug.traceback())
	if string.endswith(path, "/") then
		for index, file in ipairs(SnowyStream.QueryFiles(path)) do
			self:BuildUpdatedRecursive(path .. file, tree, forceRecompile)
		end
	elseif string.endswith(path, ".tl") or string.endswith(path, ".tlm") then
		self:BuildUpdatedOne(path, tree, forceRecompile)
	end
end

function QuickCompile:CompileRecursive(path, forceRecompile)
	local filelist = {}
	self:BuildUpdatedRecursive(path, filelist, forceRecompile)
	for k, v in SortedPairs(filelist) do
		if v then
			self:CompileOne(k, v)
		end
	end
end

function QuickCompile.New()
	local compiler = {}
	compiler.cache = {}
	return setmetatable(compiler, { __index = QuickCompile })
end

local function Main(inputFileName)
	if inputFileName then
		local compiler = QuickCompile.New()
		compiler:CompileRecursive(inputFileName, true)
	end
end

Main(...)
return QuickCompile
